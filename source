#include <iostream>
#include <clocale>
#include <cmath>
#include <ctime>
#include <chrono>
#include <fstream>
using namespace std;
void merge(long int* arr[], int p, int q, int r) {
    int n1 = q - p + 1;
    int n2 = r - q;
    long int* L = new long int[n1];
    long int* M = new long int[n2];
    for (int i = 0; i < n1; i++)
        L[i] = arr[p + i];
    for (int j = 0; j < n2; j++)
        M[j] = arr[q + 1 + j];
    int i, j, k;
    i = 0;
    j = 0;
    k = p;
    while (i < n1 && j < n2) {
        if (L[i] <= M[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = M[j];
            j++;
        }
        k++;
    }
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = M[j];
        j++;
        k++;
    }
}
double mergeSort(long int* arr[], int l, int r)
{
    double start_merge = clock();
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
    double end_merge = clock();
    double search_merge = end_merge - start_merge;
    return search_merge;
}
double shell(long int* a , int size)
{
	double start_shell = clock();
	int  j, gap, h;
	gap = size / 2;
	while (gap>0)
	{
		for (int i = 0; i < (size - gap); i++)
		{
			j = i;
			while ((j >= 0) && (a[j] > a[j + gap]))
			{
				h = a[j];
				a[j] = a[j + gap];
				a[j + gap] = h;
				j--;
			}
		}
		gap /= 2;
	}	
	double end_shell = clock();
	double search_shell = end_shell - start_shell;
	return search_shell;
}
void heapify(long int* arr[], int n, int i)
{
	int largest = i;
	int left = 2 * i + 1;
	int right = 2 * i + 2;
	if (left < n && arr[left] > arr[largest])
		largest = left;
	if (right < n && arr[right] > arr[largest])
		largest = right;
	if (largest != i)
	{
		swap(arr[i], arr[largest]);
		heapify(arr, n, largest);
	}
}
double heapSort(long int arr[], int n)
{
    double start_heap = clock();
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    for (int i = n - 1; i >= 0; i--)
    {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
    double end_heap = clock();
    double search_heap = end_heap - start_heap;
}
double quickSort(long int* ar, int lo, int hi)
{
    double start_quick = clock();
    if (lo < hi) {
        int p = ar[hi];
        int i = lo - 1;
        for (int j = lo; j < hi; ++j)
            if (ar[j] <= p)
                swap(ar[++i], ar[j]);
        if (ar[hi] < ar[i + 1])
            swap(ar[i + 1], ar[hi]);
        int prt = i + 1;
        quickSort(ar, lo, prt - 1);
        quickSort(ar, prt + 1, hi);
    }
    double end_quick = clock();
    double search_quick = end_quick - start_quick;
    return search_quick;
}
double insertSort(long int* array[], int size) 
{
    double start_insert = clock();
    for (int step = 1; step < size; step++) {
        int key = array[step];
        int j = step - 1;
        while (key < array[j] && j >= 0) {
            array[j + 1] = array[j];
            --j;
        }
        array[j + 1] = key;
    }
    double end_insert = clock();
    double search_insert = end_insert - start_insert;
    return search_insert;
}
int main()
{
	long int n;
	n = 10000000;	
	ofstream fole;
	fole.open("output.txt");
	srand(time(0));
	fole << "test â„–  " << " shell " << " heap " << " merge " << " quick " << " insert " << endl;
	for (int t = 0; t < 1000; t++)
	{
		long int* a = new int[n];
		long int* b = new int[n];
		long int* c = new int[n];
		long int* d = new int[n];
		long int* e = new int[n];
		long int* f = new int[n];
		for (int i = 0; i < n; i++)
		{
			a[i] = rand() % 100 + 1;
			b[i] = a[i];
			c[i] = a[i];
			d[i] = a[i];
			e[i] = a[i];
		}		
		double search_shell= shell(a, n);
		double search_heap = heapSort(b, n);
		double search_merge = mergeSort(c, 0, n - 1);
		double search_quick = quickSort(d, 0, n - 1);
		double search_insert = insertSort(e, n);
		fole << t << "          " << search_shell << "      " << search_heap << "      "<< search_merge << "      "<< search_quick << "      "<< search_insert  << endl;
		delete[] a;
		delete[] b;
		delete[] c;
		delete[] d;
		delete[] e;
		delete[] f;
		
	}
	return 0;
}
